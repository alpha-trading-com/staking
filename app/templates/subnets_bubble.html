<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subnet Price Bubbles</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            background: linear-gradient(135deg, #181c24 0%, #232a36 100%);
            color: #e5e7eb;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        .container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .header {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: transparent;
            padding: 1rem 2rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        h1 {
            color: #fff;
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            color: #cbd5e1;
            font-size: 1rem;
        }
        
        #chart-container {
            background: #232a36;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
        
        .bubble {
            cursor: pointer;
            transition: opacity 0.2s ease;
        }
        
        .bubble:hover {
            opacity: 0.8;
            stroke: #60a5fa;
            stroke-width: 3px;
        }
        
        .bubble-text {
            pointer-events: none;
            font-weight: 600;
            fill: #fff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }
        
        .tooltip {
            position: absolute;
            background: rgba(35, 42, 54, 0.98);
            border: 1px solid #60a5fa;
            border-radius: 8px;
            padding: 12px 16px;
            pointer-events: none;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .tooltip-title {
            font-weight: 700;
            color: #60a5fa;
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            gap: 20px;
        }
        
        .tooltip-label {
            color: #9ca3af;
        }
        
        .tooltip-value {
            color: #e5e7eb;
            font-weight: 600;
        }
        
        .loading {
            text-align: center;
            padding: 4rem;
            color: #9ca3af;
            font-size: 1.2rem;
        }
        
        .error {
            text-align: center;
            padding: 2rem;
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 8px;
            margin: 2rem;
        }
        
        .back-btn {
            background: #2563eb;
            color: #fff;
            padding: 0.5rem 1.2rem;
            border-radius: 6px;
            text-decoration: none;
            display: inline-block;
            margin-bottom: 1rem;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .back-btn:hover {
            background: #3b82f6;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .legend-label {
            color: #cbd5e1;
            font-size: 0.9rem;
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 3rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #60a5fa;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #9ca3af;
            margin-top: 0.25rem;
        }
        
        .bubble.hidden {
            opacity: 0.1;
            pointer-events: none;
        }
        
        .bubble-group.hidden {
            opacity: 0.1;
            pointer-events: none;
        }
        
        .filter-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 10;
            background: rgba(35, 42, 54, 0.95);
            border: 1px solid #60a5fa;
            border-radius: 8px;
            padding: 1rem;
            min-width: 250px;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .filter-controls h3 {
            color: #60a5fa;
            font-size: 1rem;
            font-weight: 600;
            margin: 0 0 0.75rem 0;
        }
        
        .filter-input {
            width: 100%;
            background: #181c24;
            color: #e5e7eb;
            border: 1px solid #60a5fa;
            border-radius: 6px;
            padding: 0.5rem;
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
            box-sizing: border-box;
        }
        
        .filter-input:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        .filter-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .filter-btn {
            flex: 1;
            background: #2563eb;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 0.5rem;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .filter-btn:hover {
            background: #3b82f6;
        }
        
        .filter-btn.secondary {
            background: #475569;
        }
        
        .filter-btn.secondary:hover {
            background: #64748b;
        }
        
        .hidden-list {
            margin-top: 0.75rem;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .hidden-list-title {
            color: #9ca3af;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }
        
        .hidden-item {
            background: #181c24;
            border: 1px solid #475569;
            border-radius: 4px;
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .hidden-item:hover {
            background: #232a36;
            border-color: #60a5fa;
        }
        
        .hidden-item-name {
            color: #e5e7eb;
            font-weight: 500;
        }
        
        .hidden-item-netuid {
            color: #9ca3af;
        }
        
        .bubble-count {
            color: #cbd5e1;
            font-size: 0.85rem;
            margin-top: 0.5rem;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="display: flex; gap: 1.5rem; align-items: center; flex-wrap: nowrap; justify-content: center; white-space: nowrap;">
                <div style="display: flex; align-items: center;">
                <a href="https://taostats.io/subnets" target="_blank" class="back-btn" style="margin:0;display: flex; align-items: center;">Taostats</a>
                </div>
                <div style="display: flex; align-items: center;">
                    <label for="period-select" style="color: #cbd5e1; margin-right: 0.5rem; display: flex; align-items: center;">Price Change Period:</label>
                    <select id="period-select" style="background: #232a36; color: #e5e7eb; border: 1px solid #60a5fa; border-radius: 6px; padding: 0.5rem 1rem; font-size: 0.9rem; cursor: pointer;">
                        <option value="5">Last 5 minutes</option>
                        <option value="15">Last 15 minutes</option>
                        <option value="30">Last 30 minutes</option>
                        <option value="60">Last 1 hour</option>
                        <option value="240">Last 4 hours</option>
                        <option value="1440" selected>Last 24 hours</option>
                    </select>
                </div>
                <div style="display: flex; align-items: center;">
                    <label for="size-select" style="color: #cbd5e1; margin-right: 0.5rem; display: flex; align-items: center;">Bubble Size By:</label>
                    <select id="size-select" style="background: #232a36; color: #e5e7eb; border: 1px solid #60a5fa; border-radius: 6px; padding: 0.5rem 1rem; font-size: 0.9rem; cursor: pointer;">
                        <option value="price" selected>Price</option>
                        <option value="priceChange">Price Change</option>
                    </select>
                </div>
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <label for="size-min" style="color: #cbd5e1; display: flex; align-items: center;">Size Range:</label>
                    <input type="number" id="size-min" min="10" max="200" value="30" style="background: #232a36; color: #e5e7eb; border: 1px solid #60a5fa; border-radius: 6px; padding: 0.5rem; font-size: 0.9rem; width: 60px; text-align: center;">
                    <span style="color: #cbd5e1;">-</span>
                    <input type="number" id="size-max" min="10" max="200" value="90" style="background: #232a36; color: #e5e7eb; border: 1px solid #60a5fa; border-radius: 6px; padding: 0.5rem; font-size: 0.9rem; width: 60px; text-align: center;">
                </div>
                <div style="display: flex; align-items: center;">
                    <button id="filter-toggle-btn" class="back-btn" style="margin:0;">Filter Subnets</button>
                </div>
            </div>
        </div>
        
        <!-- <div class="stats" id="stats">
            <div class="stat-item">
                <div class="stat-value" id="total-subnets">-</div>
                <div class="stat-label">Total Subnets</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="avg-price">-</div>
                <div class="stat-label">Average Price</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="highest-price">-</div>
                <div class="stat-label">Highest Price</div>
            </div>
        </div> -->
        
        <div class="filter-controls" id="filter-controls" style="display: none;">
            <h3>Filter Subnets</h3>
            <input type="text" id="subnet-search" class="filter-input" placeholder="Search by name or netuid...">
            <div class="filter-buttons">
                <button class="filter-btn" id="show-all-btn">Show All</button>
                <button class="filter-btn secondary" id="hide-all-btn">Hide All</button>
            </div>
            <div class="bubble-count" id="bubble-count">Visible: 0 / Total: 0</div>
            <div class="hidden-list" id="hidden-list" style="display: none;">
                <div class="hidden-list-title">Hidden Subnets (click to show):</div>
                <div id="hidden-items"></div>
            </div>
        </div>
        
        <div id="chart-container">
            <div class="loading" id="loading">Loading subnet data...</div>
        </div>
        
        <!--         <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #22c55e;"></div>
                <span class="legend-label">Price Increased</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ef4444;"></div>
                <span class="legend-label">Price Decreased</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6b7280;"></div>
                <span class="legend-label">No Change</span>
            </div>
        </div> -->
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        let currentData = null;
        let hiddenSubnets = new Set(); // Track hidden subnet netuids
        let allNodes = []; // Store all nodes for physics updates
        
        // localStorage keys
        const STORAGE_KEY_HIDDEN = 'subnets_bubble_hidden';
        const STORAGE_KEY_SEARCH = 'subnets_bubble_search';
        
        // Save hidden subnets to localStorage
        function saveHiddenSubnets() {
            try {
                const hiddenArray = Array.from(hiddenSubnets);
                localStorage.setItem(STORAGE_KEY_HIDDEN, JSON.stringify(hiddenArray));
            } catch (e) {
                console.warn('Failed to save hidden subnets to localStorage:', e);
            }
        }
        
        // Load hidden subnets from localStorage
        function loadHiddenSubnets() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY_HIDDEN);
                if (saved) {
                    const hiddenArray = JSON.parse(saved);
                    hiddenSubnets = new Set(hiddenArray.map(id => parseInt(id)));
                }
            } catch (e) {
                console.warn('Failed to load hidden subnets from localStorage:', e);
                hiddenSubnets = new Set();
            }
        }
        
        // Save search filter to localStorage
        function saveSearchFilter(value) {
            try {
                const searchValue = value !== undefined ? value : document.getElementById('subnet-search').value;
                localStorage.setItem(STORAGE_KEY_SEARCH, searchValue || '');
            } catch (e) {
                console.warn('Failed to save search filter to localStorage:', e);
            }
        }
        
        // Load search filter from localStorage
        function loadSearchFilter() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY_SEARCH);
                return saved || '';
            } catch (e) {
                console.warn('Failed to load search filter from localStorage:', e);
                return '';
            }
        }
        
        // Fetch subnet data and render visualization
        async function loadSubnetData() {
            const selectedPeriod = parseInt(document.getElementById('period-select').value);
            
            try {
                const response = await fetch(`/subnets_data?period_minutes=${selectedPeriod}`);
                const data = await response.json();
                
                if (!data.success) {
                    showError(data.error || 'Failed to load subnet data');
                    return;
                }
                
                // Map server data to use priceChange field
                currentData = data.subnets.map(subnet => ({
                    ...subnet,
                    priceChange: subnet.price_change || 0
                }));
                
                // Load saved search filter first
                const savedSearch = loadSearchFilter();
                const searchInput = document.getElementById('subnet-search');
                
                if (savedSearch && savedSearch.trim() && searchInput) {
                    // If there's a saved search, apply it (this will set hiddenSubnets)
                    searchInput.value = savedSearch;
                    const searchTerm = savedSearch.toLowerCase().trim();
                    hiddenSubnets.clear(); // Start fresh
                    currentData.forEach(subnet => {
                        const matches = subnet.name.toLowerCase().includes(searchTerm) || 
                                      subnet.netuid.toString().includes(searchTerm);
                        if (!matches) {
                            hiddenSubnets.add(subnet.netuid);
                        }
                    });
                } else {
                    // If no search, load saved hidden subnets
                    loadHiddenSubnets();
                    // Filter out netuids that don't exist in current data
                    const validNetuids = new Set(currentData.map(s => s.netuid));
                    hiddenSubnets = new Set(Array.from(hiddenSubnets).filter(id => validNetuids.has(id)));
                    if (searchInput) {
                        searchInput.value = '';
                    }
                }
                
                // Clear previous chart
                const loadingEl = document.getElementById('loading');
                if (loadingEl) loadingEl.style.display = 'none';
                document.getElementById('chart-container').innerHTML = '';
                
                renderBubbleChart(currentData);
                updateStats(currentData);
                
                // Update UI after rendering
                updateBubbleVisibility();
                updateHiddenList();
                
                // Save the final state (with cleaned up netuids)
                saveHiddenSubnets();
                
                // Display period info
                console.log(`Showing price changes from block ${data.historical_block} to ${data.current_block} (${data.period_minutes} minutes)`);
                
            } catch (error) {
                console.error('Error loading subnet data:', error);
                showError('Failed to load subnet data. Please try again.');
            }
        }
        
        function updateVisualization() {
            // Simply reload data from server with new period
            loadSubnetData();
        }
        
        // Listen for period and size changes
        document.addEventListener('DOMContentLoaded', () => {
            loadSubnetData();
            
            // Filter controls toggle
            const filterToggleBtn = document.getElementById('filter-toggle-btn');
            const filterControls = document.getElementById('filter-controls');
            filterToggleBtn.addEventListener('click', () => {
                const isVisible = filterControls.style.display !== 'none';
                filterControls.style.display = isVisible ? 'none' : 'block';
                filterToggleBtn.textContent = isVisible ? 'Filter Subnets' : 'Hide Filters';
            });
            
            // Search functionality
            const subnetSearch = document.getElementById('subnet-search');
            subnetSearch.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase().trim();
                saveSearchFilter(e.target.value); // Save search filter
                
                if (!searchTerm) {
                    // Show all if search is empty
                    hiddenSubnets.clear();
                    updateBubbleVisibility();
                    updateHiddenList();
                    saveHiddenSubnets(); // Save to localStorage
                    return;
                }
                
                // Hide all subnets that don't match
                if (currentData) {
                    currentData.forEach(subnet => {
                        const matches = subnet.name.toLowerCase().includes(searchTerm) || 
                                      subnet.netuid.toString().includes(searchTerm);
                        if (matches) {
                            hiddenSubnets.delete(subnet.netuid);
                        } else {
                            hiddenSubnets.add(subnet.netuid);
                        }
                    });
                    updateBubbleVisibility();
                    updateHiddenList();
                    saveHiddenSubnets(); // Save to localStorage
                }
            });
            
            // Show all button
            document.getElementById('show-all-btn').addEventListener('click', () => {
                hiddenSubnets.clear();
                subnetSearch.value = '';
                saveSearchFilter(''); // Clear saved search
                updateBubbleVisibility();
                updateHiddenList();
                saveHiddenSubnets(); // Save to localStorage
            });
            
            // Hide all button
            document.getElementById('hide-all-btn').addEventListener('click', () => {
                if (currentData) {
                    currentData.forEach(subnet => {
                        if (subnet.price <= 0.8) {
                            hiddenSubnets.add(subnet.netuid);
                        }
                    });
                    updateBubbleVisibility();
                    updateHiddenList();
                    saveHiddenSubnets(); // Save to localStorage
                }
            });
            
            document.getElementById('period-select').addEventListener('change', () => {
                const container = document.getElementById('chart-container');
                container.innerHTML = '<div class="loading" id="loading">Loading data for selected period...</div>';
                hiddenSubnets.clear(); // Reset hidden subnets when period changes
                subnetSearch.value = '';
                saveHiddenSubnets(); // Save cleared state
                saveSearchFilter(''); // Clear saved search
                loadSubnetData();
            });
            
            document.getElementById('size-select').addEventListener('change', () => {
                if (currentData) {
                    const container = document.getElementById('chart-container');
                    container.innerHTML = '';
                    renderBubbleChart(currentData);
                }
            });
            
            // Listen for bubble size range changes
            const sizeMinInput = document.getElementById('size-min');
            const sizeMaxInput = document.getElementById('size-max');
            
            function updateBubbleSizes() {
                const minSize = parseInt(sizeMinInput.value) || 30;
                const maxSize = parseInt(sizeMaxInput.value) || 90;
                
                // Validate: ensure min < max
                if (minSize >= maxSize) {
                    if (sizeMinInput === document.activeElement) {
                        sizeMaxInput.value = Math.min(200, minSize + 1);
                    } else {
                        sizeMinInput.value = Math.max(10, maxSize - 1);
                    }
                    return;
                }
                
                if (currentData) {
                    const container = document.getElementById('chart-container');
                    container.innerHTML = '';
                    renderBubbleChart(currentData);
                }
            }
            
            sizeMinInput.addEventListener('input', updateBubbleSizes);
            sizeMinInput.addEventListener('change', updateBubbleSizes);
            sizeMaxInput.addEventListener('input', updateBubbleSizes);
            sizeMaxInput.addEventListener('change', updateBubbleSizes);
        });
        
        // Update bubble visibility based on hiddenSubnets set
        function updateBubbleVisibility() {
            allNodes.forEach(node => {
                const isHidden = hiddenSubnets.has(node.netuid);
                const group = d3.select(node.element);
                if (group.empty()) return;
                
                if (isHidden) {
                    group.classed('hidden', true);
                    group.style('pointer-events', 'none');
                } else {
                    group.classed('hidden', false);
                    group.style('pointer-events', 'all');
                }
            });
            updateBubbleCount();
        }
        
        // Update bubble count display
        function updateBubbleCount() {
            if (!currentData) return;
            const validSubnets = currentData.filter(s => s.price <= 0.8);
            const visibleCount = validSubnets.filter(s => !hiddenSubnets.has(s.netuid)).length;
            const totalCount = validSubnets.length;
            document.getElementById('bubble-count').textContent = `Visible: ${visibleCount} / Total: ${totalCount}`;
        }
        
        // Update hidden subnets list
        function updateHiddenList() {
            const hiddenList = document.getElementById('hidden-list');
            const hiddenItems = document.getElementById('hidden-items');
            
            if (hiddenSubnets.size === 0) {
                hiddenList.style.display = 'none';
                return;
            }
            
            hiddenList.style.display = 'block';
            hiddenItems.innerHTML = '';
            
            if (!currentData) return;
            
            const hiddenSubnetsList = currentData
                .filter(s => hiddenSubnets.has(s.netuid) && s.price <= 0.8)
                .sort((a, b) => a.netuid - b.netuid);
            
            hiddenSubnetsList.forEach(subnet => {
                const item = document.createElement('div');
                item.className = 'hidden-item';
                item.innerHTML = `
                    <span class="hidden-item-name">${subnet.name}</span>
                    <span class="hidden-item-netuid">#${subnet.netuid}</span>
                `;
                item.addEventListener('click', () => {
                    hiddenSubnets.delete(subnet.netuid);
                    updateBubbleVisibility();
                    updateHiddenList();
                    saveHiddenSubnets(); // Save to localStorage
                });
                hiddenItems.appendChild(item);
            });
        }
        
        function showError(message) {
            const loadingEl = document.getElementById('loading');
            if (loadingEl) loadingEl.style.display = 'none';
            const container = document.getElementById('chart-container');
            container.innerHTML = `<div class="error">${message}</div>`;
        }
        
        function updateStats(subnets) {
            const validSubnets = subnets.filter(s => s.price <= 0.8);
            const totalSubnets = validSubnets.length;
            const avgPrice = totalSubnets > 0 
                ? (validSubnets.reduce((sum, s) => sum + s.price, 0) / totalSubnets).toFixed(4)
                : '0.0000';
            const highestPrice = totalSubnets > 0
                ? Math.max(...validSubnets.map(s => s.price)).toFixed(4)
                : '0.0000';
            
            // Only update stats if the elements exist (stats section may be commented out)
            const totalSubnetsEl = document.getElementById('total-subnets');
            const avgPriceEl = document.getElementById('avg-price');
            const highestPriceEl = document.getElementById('highest-price');
            
            if (totalSubnetsEl) totalSubnetsEl.textContent = totalSubnets;
            if (avgPriceEl) avgPriceEl.textContent = avgPrice + ' τ';
            if (highestPriceEl) highestPriceEl.textContent = highestPrice + ' τ';
        }
        
        function renderBubbleChart(subnets) {
            // Filter out subnets with price less than 0.8
            const validSubnets = subnets.filter(s => s.price <= 0.8);
            
            if (validSubnets.length === 0) {
                showError('No subnet data available');
                return;
            }
            
            const container = document.getElementById('chart-container');
            // Use full viewport dimensions for full screen
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            // Create SVG
            const svg = d3.select('#chart-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Get bubble size option
            const sizeBy = document.getElementById('size-select').value;
            
            // Get bubble size range from inputs
            const minSize = parseInt(document.getElementById('size-min').value) || 30;
            const maxSize = parseInt(document.getElementById('size-max').value) || 90;
            const sizeRange = [Math.max(10, Math.min(200, minSize)), Math.max(10, Math.min(200, maxSize))];
            
            // Calculate bubble sizes based on selected option
            let sizeScale;
            if (sizeBy === 'priceChange') {
                // Size by absolute price change
                const priceChanges = validSubnets.map(d => Math.abs(d.priceChange || 0));
                const maxChange = d3.max(priceChanges);
                const minChange = d3.min(priceChanges);
                sizeScale = d3.scaleSqrt()
                    .domain([minChange, maxChange])
                    .range(sizeRange);
            } else {
                // Size by price (default)
                const maxPrice = d3.max(validSubnets, d => d.price);
                const minPrice = d3.min(validSubnets, d => d.price);
                sizeScale = d3.scaleSqrt()
                    .domain([minPrice, maxPrice])
                    .range(sizeRange);
            }
            
            // Color scale based on price change
            const colorScale = d => {
                if (d.priceChange > 0) return '#22c55e'; // Green for increase
                if (d.priceChange < 0) return '#ef4444'; // Red for decrease
                return '#6b7280'; // Gray for no change
            };
            
            // Prepare data with initial positions using D3 force layout for initial placement
            const nodes = validSubnets.map(subnet => ({
                ...subnet,
                radius: sizeBy === 'priceChange' 
                    ? sizeScale(Math.abs(subnet.priceChange || 0))
                    : sizeScale(subnet.price)
            }));
            
            // Use D3 force simulation just for initial positioning
            const simulation = d3.forceSimulation(nodes)
                .force('charge', d3.forceManyBody().strength(5))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => d.radius + 2))
                .force('x', d3.forceX(width / 2).strength(0.05))
                .force('y', d3.forceY(height / 2).strength(0.05))
                .stop();
            
            // Run simulation to get initial positions
            for (let i = 0; i < 300; ++i) simulation.tick();
            
            // Create bubble groups
            const bubbleGroups = svg.selectAll('.bubble-group')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', 'bubble-group')
                .attr('transform', d => `translate(${d.x},${d.y})`);
            
            // Add circles
            const bubbles = bubbleGroups.append('circle')
                .attr('class', 'bubble')
                .attr('r', d => d.radius)
                .attr('fill', d => colorScale(d))
                .attr('opacity', 0.8)
                .on('mouseover', handleMouseOver)
                .on('mousemove', handleMouseMove)
                .on('mouseout', handleMouseOut)
                .on('click', function(event, d) {
                    // Only open link if it was a click, not a drag
                    if (!hasDragged && !d.isDragging) {
                        window.open(`https://taostats.io/subnets/${d.netuid}/chart`, '_blank');
                    }
                    hasDragged = false; // Reset for next interaction
                })
                .on('contextmenu', function(event, d) {
                    event.preventDefault(); // Prevent default context menu
                    // Toggle hide/show on right-click
                    if (hiddenSubnets.has(d.netuid)) {
                        hiddenSubnets.delete(d.netuid);
                    } else {
                        hiddenSubnets.add(d.netuid);
                    }
                    updateBubbleVisibility();
                    updateHiddenList();
                    saveHiddenSubnets(); // Save to localStorage
                });
            
            // Add text labels (show netuid, price, and percentage)
            bubbleGroups.each(function(d) {
                const group = d3.select(this);
                const baseFontSize = Math.max(12, d.radius / 2.5);
                const netuidFontSize = baseFontSize;
                const priceFontSize = baseFontSize * 0.75;
                const changeFontSize = baseFontSize * 0.65;
                
                // Calculate line height based on font size (reduced spacing)
                const lineHeight = baseFontSize * 0.9;
                
                // Calculate total height of text block and center it
                const hasChange = d.priceChange !== 0;
                const totalLines = hasChange ? 3 : 2;
                const totalHeight = (totalLines - 1) * lineHeight;
                const startY = -totalHeight / 2;
                
                // Add netuid text (top line)
                group.append('text')
                    .attr('class', 'bubble-text')
                    .attr('text-anchor', 'middle')
                    .attr('y', startY)
                    .text(d.netuid)
                    .style('font-size', netuidFontSize + 'px')
                    .style('font-weight', '700')
                    .style('fill', '#fff');
                
                // Add price text (middle line)
                const priceText = d.price.toFixed(4) + ' τ';
                group.append('text')
                    .attr('class', 'bubble-text')
                    .attr('text-anchor', 'middle')
                    .attr('y', startY + lineHeight)
                    .text(priceText)
                    .style('font-size', priceFontSize + 'px')
                    .style('font-weight', '600')
                    .style('fill', '#fff');
                
                // Add percentage text if there's a change (bottom line)
                if (hasChange) {
                    const changeText = (d.priceChange > 0 ? '+' : '') + d.priceChange.toFixed(1) + '%';
                    group.append('text')
                        .attr('class', 'bubble-text')
                        .attr('text-anchor', 'middle')
                        .attr('y', startY + lineHeight * 2)
                        .text(changeText)
                        .style('font-size', changeFontSize + 'px')
                        .style('font-weight', '600')
                        .style('fill', '#fff');
                }
            });
            
            // Physics-based animation with collision detection
            nodes.forEach(node => {
                node.vx = (Math.random() - 0.5) * 2; // Random velocity
                node.vy = (Math.random() - 0.5) * 2;
                node.element = null;
                node.isDragging = false; // Track if node is being dragged
            });
            
            bubbleGroups.each(function(d, i) {
                d.element = this;
            });
            
            // Store all nodes for visibility updates
            allNodes = nodes;
            
            // Apply initial visibility state
            nodes.forEach(node => {
                if (hiddenSubnets.has(node.netuid)) {
                    const group = d3.select(node.element);
                    group.classed('hidden', true);
                    group.style('pointer-events', 'none');
                }
            });
            
            // Update counts and lists
            updateBubbleCount();
            updateHiddenList();
            
            // Track drag distance to distinguish from clicks
            let dragStartPos = null;
            let hasDragged = false;
            
            // Add drag behavior
            const drag = d3.drag()
                .on('start', function(event, d) {
                    dragStartPos = { x: event.x, y: event.y };
                    hasDragged = false;
                    d.isDragging = true;
                    d.vx = 0;
                    d.vy = 0;
                    d3.select(this).raise().attr('stroke', '#60a5fa').attr('stroke-width', 3);
                })
                .on('drag', function(event, d) {
                    // Check if mouse has moved significantly (more than 5px)
                    if (dragStartPos) {
                        const dx = Math.abs(event.x - dragStartPos.x);
                        const dy = Math.abs(event.y - dragStartPos.y);
                        if (dx > 5 || dy > 5) {
                            hasDragged = true;
                        }
                    }
                    d.x = event.x;
                    d.y = event.y;
                    d3.select(this).attr('transform', `translate(${d.x},${d.y})`);
                })
                .on('end', function(event, d) {
                    d.isDragging = false;
                    // Give it a small random velocity when released
                    d.vx = (Math.random() - 0.5) * 0.5;
                    d.vy = (Math.random() - 0.5) * 0.5;
                    d3.select(this).attr('stroke', null);
                    dragStartPos = null;
                });
            
            // Apply drag to bubble groups
            bubbleGroups.call(drag);
            
            // Collision detection and physics update
            function updatePhysics() {
                // Update positions (skip nodes being dragged or hidden)
                nodes.forEach(node => {
                    if (node.isDragging || hiddenSubnets.has(node.netuid)) return; // Skip physics for dragged or hidden nodes
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    // Bounce off walls
                    if (node.x - node.radius < 0 || node.x + node.radius > width) {
                        node.vx *= -0.8;
                        node.x = Math.max(node.radius, Math.min(width - node.radius, node.x));
                    }
                    if (node.y - node.radius < 0 || node.y + node.radius > height) {
                        node.vy *= -0.8;
                        node.y = Math.max(node.radius, Math.min(height - node.radius, node.y));
                    }
                    
                    // Apply slight friction
                    node.vx *= 0.995;
                    node.vy *= 0.995;
                    
                    // Keep minimum velocity
                    const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
                    if (speed < 0.5) {
                        node.vx += (Math.random() - 0.5) * 0.2;
                        node.vy += (Math.random() - 0.5) * 0.2;
                    }
                });
                
                // Check collisions between bubbles (skip dragged or hidden nodes)
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const node1 = nodes[i];
                        const node2 = nodes[j];
                        
                        // Skip collision if either node is being dragged or hidden
                        if (node1.isDragging || node2.isDragging || 
                            hiddenSubnets.has(node1.netuid) || hiddenSubnets.has(node2.netuid)) continue;
                        
                        const dx = node2.x - node1.x;
                        const dy = node2.y - node1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDist = node1.radius + node2.radius;
                        
                        if (distance < minDist) {
                            // Collision detected! Bounce in opposite directions
                            const angle = Math.atan2(dy, dx);
                            const sin = Math.sin(angle);
                            const cos = Math.cos(angle);
                            
                            // Rotate velocities
                            const vx1 = node1.vx * cos + node1.vy * sin;
                            const vy1 = node1.vy * cos - node1.vx * sin;
                            const vx2 = node2.vx * cos + node2.vy * sin;
                            const vy2 = node2.vy * cos - node2.vx * sin;
                            
                            // Swap velocities (elastic collision)
                            const vx1Final = vx2;
                            const vx2Final = vx1;
                            
                            // Rotate back
                            node1.vx = vx1Final * cos - vy1 * sin;
                            node1.vy = vy1 * cos + vx1Final * sin;
                            node2.vx = vx2Final * cos - vy2 * sin;
                            node2.vy = vy2 * cos + vx2Final * sin;
                            
                            // Separate bubbles to prevent sticking
                            const overlap = minDist - distance;
                            const separateX = (dx / distance) * overlap * 0.5;
                            const separateY = (dy / distance) * overlap * 0.5;
                            node1.x -= separateX;
                            node1.y -= separateY;
                            node2.x += separateX;
                            node2.y += separateY;
                        }
                    }
                }
                
                // Update DOM
                nodes.forEach(node => {
                    if (node.element) {
                        node.element.setAttribute('transform', `translate(${node.x},${node.y})`);
                    }
                });
                
                requestAnimationFrame(updatePhysics);
            }
            
            // Start animation
            updatePhysics();
            
            // Tooltip functions
            const tooltip = d3.select('#tooltip');
            
            function handleMouseOver(event, d) {
                tooltip.style('opacity', 1);
                d3.select(this).attr('stroke', '#60a5fa').attr('stroke-width', 3);
            }
            
            function handleMouseMove(event, d) {
                const priceChangeHtml = d.priceChange !== 0 
                    ? `<div class="tooltip-row">
                        <span class="tooltip-label">Price Change:</span>
                        <span class="tooltip-value" style="color: ${d.priceChange > 0 ? '#22c55e' : '#ef4444'}">
                            ${d.priceChange > 0 ? '+' : ''}${d.priceChange.toFixed(2)}%
                        </span>
                    </div>`
                    : '';
                
                const tooltipHtml = `
                    <div class="tooltip-title">Subnet ${d.netuid}</div>
                    <div class="tooltip-row">
                        <span class="tooltip-label">Name:</span>
                        <span class="tooltip-value">${d.name}</span>
                    </div>
                    <div class="tooltip-row">
                        <span class="tooltip-label">Price:</span>
                        <span class="tooltip-value">${d.price.toFixed(6)} τ</span>
                    </div>
                    ${priceChangeHtml}
                    <div class="tooltip-row">
                        <span class="tooltip-label">TAO In:</span>
                        <span class="tooltip-value">${d.tao_in.toFixed(2)} τ</span>
                    </div>
                    <div class="tooltip-row">
                        <span class="tooltip-label">Alpha In:</span>
                        <span class="tooltip-value">${d.alpha_in.toFixed(2)}</span>
                    </div>
                    <div class="tooltip-row">
                        <span class="tooltip-label">Type:</span>
                        <span class="tooltip-value">${d.is_dynamic ? 'Dynamic' : 'Static'}</span>
                    </div>
                `;
                
                tooltip.html(tooltipHtml)
                    .style('left', (event.pageX + 15) + 'px')
                    .style('top', (event.pageY - 15) + 'px');
            }
            
            function handleMouseOut(event, d) {
                tooltip.style('opacity', 0);
                d3.select(this).attr('stroke', null);
            }
        }
        
    </script>
</body>
</html>

